(node:59721) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)
No need to generate any newer typings.

  UniswapV3Connector - swapAndAddLiquidity
    #swapAndAddLiquidity
=== Test: Create new position ===
Amount0Desired: 100000000000
Amount1Desired: 80000000000
TickLower: -500
TickUpper: 500
Approving tokens...
Balance before - TokenA: 1000000000000
Balance before - TokenB: 1000000000000
Executing swapAndAddLiquidity...
Basic validations passed
Token transfers and approvals completed
Pool address: 0xa513e6e4b8f2a923d98304ec87f64353c4d5c853
Current sqrt price: 79228162514264337593543950336
Calculating liquidity amounts
Max liquidity: 3240326653931
Optimal amount0: 79999999999
Optimal amount1: 79999999999
Range ratio: 1000000000000000000
Current ratio: 1250000000000000000
Executing swap: token0 -> token1
Initial guess: 20000000000
Left: 1
Right: 45000000000
Right after: 45000000000
Mid: 22500000000

      1) should successfully create a new position with optimal token ratios

Â·---------------------------------------------|---------------------------|-------------|-----------------------------Â·
|            [90mSolc version: 0.5.16[39m             Â·  [90mOptimizer enabled: true[39m  Â·  [90mRuns: 200[39m  Â·  [90mBlock limit: 30000000 gas[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mMethods[22m[39m                                                                                                            â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [1mContract[22m            Â·  [1mMethod[22m              Â·  [32mMin[39m        Â·  [32mMax[39m        Â·  [32mAvg[39m        Â·  [1m# calls[22m      Â·  [1musd (avg)[22m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90merc20[39m               Â·  approve             Â·          -  Â·          -  Â·      46204  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90merc20[39m               Â·  transfer            Â·          -  Â·          -  Â·      51649  Â·            [90m2[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mUniswapV3Connector[39m  Â·  initialize          Â·          -  Â·          -  Â·     237687  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mUniswapV3Connector[39m  Â·  setFeeTier          Â·          -  Â·          -  Â·      69196  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mUniswapV3Connector[39m  Â·  setPositionManager  Â·          -  Â·          -  Â·      46282  Â·            [90m1[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mDeployments[22m[39m                                Â·                                         Â·  [1m% of limit[22m   Â·             â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  erc20                                      Â·          -  Â·          -  Â·     640848  Â·        [90m2.1 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  UniswapV3Connector                         Â·          -  Â·          -  Â·    4080248  Â·       [90m13.6 %[39m  Â·          [32m[90m-[32m[39m  â”‚
Â·---------------------------------------------|-------------|-------------|-------------|---------------|-------------Â·

  0 passing (806ms)
  1 failing

  1) UniswapV3Connector - swapAndAddLiquidity
       #swapAndAddLiquidity
         should successfully create a new position with optimal token ratios:
     Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT ] (reason="VM Exception while processing transaction: reverted with reason string 'Mock on the method is not initialized'", method="estimateGas", transaction={"from":"0x70997970C51812dc3A010C7d01b50e0d17dc79C8","to":"0x0B306BF915C4d645ff596e518fAf3F9669b97016","data":"0xdf5af2eb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000005fbdb2315678afecb367f032d93f642f64180aa3000000000000000000000000e7f1725e7734ce288f8367e1bb143e90bb3f05120000000000000000000000000000000000000000000000000000000000000064fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0c00000000000000000000000000000000000000000000000000000000000001f4000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000012a05f2000","accessList":null}, error={"stackTrace":[{"type":0,"sourceReference":{"sourceName":"contracts/dex_connectors/UniswapV3Connector.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./DexConnectorStorage.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol\";\nimport \"./uniswap_v4_helpers/_LiquidityAmounts.sol\";\nimport \"./uniswap_v4_helpers/_TickMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n\n// Simplified interface for Uniswap V3 Position Manager\ninterface IPositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params) external payable returns (\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function positions(uint256 tokenId) external view returns (\n        uint96 nonce,\n        address operator,\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 tokensOwed0,\n        uint128 tokensOwed1\n    );\n}\n\ncontract UniswapV3Connector is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DexConnectorStorage\n{\n    modifier nonZeroAddress(address _address) {\n        require(_address != address(0), \"UniswapV3Connector: zero address\");\n        _;\n    }\n\n    using SafeERC20 for IERC20;\n\n    /// @notice This contract is used for interacting with UniswapV3 contract\n    /// @param _name Name of the underlying DEX\n    /// @param _exchangeRouter Address of the DEX router contract\n    function initialize(\n        string memory _name,\n        address _exchangeRouter,\n        address _quoterAddress\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        name = _name;\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n        quoterAddress = _quoterAddress;\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    function renounceOwnership() public virtual override onlyOwner {}\n\n    /// @notice Setter for wrapped native token\n    /// @dev Get address from exchange router\n    function setWrappedNativeToken() external override onlyOwner {\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    /// @notice Setter for exchange router\n    /// @dev Set address of liquidity pool factory from the exchange router\n    /// @param _exchangeRouter Address of the new exchange router contract\n    function setExchangeRouter(\n        address _exchangeRouter\n    ) external override nonZeroAddress(_exchangeRouter) onlyOwner {\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for liquidity pool factory\n    /// @dev Set address from exchange router\n    function setLiquidityPoolFactory() external override onlyOwner {\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for quoter\n    function setQuoter(address _quoterAddress) external onlyOwner {\n        quoterAddress = _quoterAddress;\n    }\n\n    /// @notice Setter for position manager\n    function setPositionManager(address _positionManager) external onlyOwner {\n        positionManager = _positionManager;\n    }\n\n    /// @notice Setter for fee tier\n    /// @dev We set the fee tier that is used for exchanging tokens\n    function setFeeTier(\n        address _firstToken,\n        address _secondToken,\n        uint24 _feeTier\n    ) external onlyOwner {\n        feeTier[_firstToken][_secondToken] = _feeTier;\n        feeTier[_secondToken][_firstToken] = _feeTier;\n    }\n\n    function convertedPath(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[0]);\n\n        for (uint i = 1; i < _path.length; i++) {\n            address firstToken = _path[i - 1];\n            address secondToken = _path[i];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    function convertedPathReversed(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[_path.length - 1]);\n\n        for (uint i = _path.length - 1; i > 0; i--) {\n            address firstToken = _path[i];\n            address secondToken = _path[i - 1];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    /// @notice Return the needed input amount to get the output amount\n    /// @dev Return (false, 0) if DEX cannot give the output amount. \n    ///      Note: No need to reverse the path for this function\n    function getExactOutput(\n        address[] memory _path,\n        uint256 _amountOut\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountIn, , , ) = IQuoterV2(quoterAddress).quoteExactOutput(\n            convertedPathReversed(_path),\n            _amountOut\n        );\n        return (true, amountIn);\n    }\n\n    /// @notice Return the output amount for the given input amount\n    /// @dev Return (false, 0) if DEX cannot swap the input amount\n    function getExactInput(\n        address[] memory _path,\n        uint256 _amountIn\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInput(\n            convertedPath(_path),\n            _amountIn\n        );\n        return (true, amountOut);\n    }\n\n    /// @notice Deprecated for v3\n    function getInputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Deprecated for v3\n    function getOutputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Return the square root price of given token pairs\n    function getSqrtPriceX96(\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint[] memory _sqrtPriceX96, address[] memory _firstToken)\n    {\n        address liquidityPool;\n        uint sqrtPriceX96;\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            (sqrtPriceX96, , , , , , ) = IUniswapV3PoolState(liquidityPool).slot0();\n            _sqrtPriceX96[i] = sqrtPriceX96;\n            if (IUniswapV3PoolImmutables(liquidityPool).token0() == _path[i]) {\n                _firstToken[i] = _path[i];\n            } else {\n                _firstToken[i] = _path[i + 1];\n            }\n        }\n    }\n\n    /// @notice Exchange input token for output token through exchange router\n    /// @dev Check exchange conditions before exchanging\n    ///      We assume that the input token is not WETH (it is teleBTC)\n    /// @param _inputAmount Amount of input token\n    /// @param _outputAmount Amount of output token\n    /// @param _path List of tokens that are used for exchanging\n    /// @param _to Receiver address\n    /// @param _deadline Deadline of exchanging tokens\n    /// @param _isFixedToken True if the input token amount is fixed\n    /// @return _result True if the exchange is successful\n    /// @return _amounts Amounts of tokens that are involved in exchanging\n    function swap(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        address _to,\n        uint256 _deadline,\n        bool _isFixedToken\n    )\n        external\n        override\n        nonReentrant\n        nonZeroAddress(_to)\n        returns (bool _result, uint[] memory _amounts)\n    {\n        uint neededInputAmount;\n        (_result, neededInputAmount) = _checkExchangeConditions(\n            _inputAmount,\n            _outputAmount,\n            _path,\n            _deadline,\n            _isFixedToken\n        );\n\n        if (_result) {\n            uint _amount;\n            _amounts = new uint[](2);\n            // Get tokens from user\n            IERC20(_path[0]).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                neededInputAmount\n            );\n\n            // Give allowance to exchange router\n            IERC20(_path[0]).approve(exchangeRouter, neededInputAmount);\n\n            if (_isFixedToken == true) {\n                _amount = ISwapRouter(exchangeRouter).exactInput(\n                    _buildInputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = neededInputAmount;\n                _amounts[1] = _amount;\n            }\n\n            if (_isFixedToken == false) {\n                _amount = ISwapRouter(exchangeRouter).exactOutput(\n                    _buildOutputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = _amount;\n                _amounts[1] = _outputAmount;\n            }\n            emit Swap(_path, _amounts, _to);\n        }\n    }\n\n    /// @notice Return true if the exchange path is valid\n    /// @param _path List of tokens that are used for exchanging\n    function isPathValid(\n        address[] memory _path\n    ) public view override returns (bool _result) {\n        address liquidityPool;\n\n        // Checks that path length is greater than one\n        if (_path.length < 2) {\n            return false;\n        }\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            if (liquidityPool == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    struct AddLiquidityParams {\n        uint256 tokenId; // 0 for new position, non-zero for existing position\n        address token0;\n        address token1;\n        uint24 feeTier;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n    }\n\n    /// @notice Zap tokens into a Uniswap V3 position in one call\n    function swapAndAddLiquidity(\n        AddLiquidityParams memory params\n    ) external nonReentrant returns (\n        uint256 _tokenId,\n        uint256 _used0,\n        uint256 _used1\n    ) {\n        // console.log(\"=== swapAndAddLiquidity START ===\");\n        // console.log(\"Position manager:\", positionManager);\n        // console.log(\"Token0:\", params.token0);\n        // console.log(\"Token1:\", params.token1);\n        // console.log(\"TokenId:\", params.tokenId);\n        // console.log(\"Amount0Desired:\", params.amount0Desired);\n        // console.log(\"Amount1Desired:\", params.amount1Desired);\n        // console.logInt(params.tickLower);\n        // console.logInt(params.tickUpper);\n        \n        // require(params.amount0Desired > 0 && params.amount1Desired > 0, \"Zero amounts\");\n\n        console.log(\"Basic validations passed\");\n\n        // If tokenId is non-zero, validate existing position parameters\n        if (params.tokenId != 0) {\n            // console.log(\"Validating existing position parameters\");\n            (\n                , , , , \n                uint24 existingFee,\n                int24 existingTickLower,\n                int24 existingTickUpper,\n                , , , , \n            ) = IPositionManager(positionManager).positions(params.tokenId);\n            \n            // console.log(\"Existing fee:\", existingFee);\n            // console.logInt(existingTickLower);\n            // console.logInt(existingTickUpper);\n            \n            require(existingFee == params.feeTier, \"Fee tier mismatch\");\n            require(existingTickLower == params.tickLower, \"Tick lower mismatch\");\n            require(existingTickUpper == params.tickUpper, \"Tick upper mismatch\");\n            // console.log(\"Existing position validation passed\");\n        }\n\n        // console.log(\"Starting token transfers and approvals\");\n\n        // 1) Pull in tokens and approve\n        IERC20(params.token0).safeTransferFrom(msg.sender, address(this), params.amount0Desired);\n        IERC20(params.token1).safeTransferFrom(msg.sender, address(this), params.amount1Desired);\n        IERC20(params.token0).approve(exchangeRouter, params.amount0Desired);\n        IERC20(params.token1).approve(exchangeRouter, params.amount1Desired);\n        IERC20(params.token0).approve(positionManager, type(uint256).max);\n        IERC20(params.token1).approve(positionManager, type(uint256).max);\n\n        console.log(\"Token transfers and approvals completed\");\n\n        \n        // Get current sqrt price from the pool\n        // console.log(\"Getting pool and sqrt price\");\n        address poolAddress = IUniswapV3Factory(liquidityPoolFactory).getPool(\n            params.token0, \n            params.token1, \n            params.feeTier\n        );\n        console.log(\"Pool address:\", poolAddress);\n        \n        (uint160 _sqrtP, , , , , , ) = IUniswapV3PoolState(poolAddress).slot0();\n        console.log(\"Current sqrt price:\", _sqrtP);\n\n        // Calculate the maximum liquidity that can be provided with the given token amounts\n        console.log(\"Calculating liquidity amounts\");\n        uint128 _maxLiquidity = _LiquidityAmounts.getLiquidityForAmounts(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            params.amount0Desired,\n            params.amount1Desired\n        );\n        console.log(\"Max liquidity:\", _maxLiquidity);\n\n        // Then get the optimal amounts for that liquidity\n        (uint256 _optimalAmount0, uint256 _optimalAmount1) = _LiquidityAmounts.getAmountsForLiquidity(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            _maxLiquidity\n        );\n        console.log(\"Optimal amount0:\", _optimalAmount0);\n        console.log(\"Optimal amount1:\", _optimalAmount1);\n\n        // 3) Execute swap if needed\n        uint256 _rangeRatio = _optimalAmount1 > 0 \n            ? (_optimalAmount0 * 1e18) / _optimalAmount1 \n            : 1e18;\n        uint256 _currentRatio = params.amount1Desired > 0 \n            ? (params.amount0Desired * 1e18) / params.amount1Desired \n            : type(uint256).max;\n        \n        console.log(\"Range ratio:\", _rangeRatio);\n        console.log(\"Current ratio:\", _currentRatio);\n        \n        if (_currentRatio > _rangeRatio) {\n            console.log(\"Executing swap: token0 -> token1\");\n            _executeSwap(\n                params.token0, \n                params.token1, \n                params.feeTier, \n                params.amount0Desired, \n                params.amount1Desired, \n                _rangeRatio\n            );\n        } else if (_currentRatio < _rangeRatio && _rangeRatio > 0) {\n            console.log(\"Executing swap: token1 -> token0\");\n            _executeSwap(\n                params.token1, \n                params.token0, \n                params.feeTier, \n                params.amount1Desired, \n                params.amount0Desired, \n                1e18 / _rangeRatio\n            );\n        } else {\n            // console.log(\"No swap needed\");\n        }\n\n        // 4) Mint position or increase liquidity and refund\n        _used0 = IERC20(params.token0).balanceOf(address(this));\n        _used1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Used amount0:\", _used0);\n        console.log(\"Used amount1:\", _used1);\n\n        if (params.tokenId == 0) {\n            // Mint new position\n            console.log(\"Minting new position\");\n            (_tokenId, , , ) = IPositionManager(positionManager).mint(\n                IPositionManager.MintParams({\n                    token0: params.token0,\n                    token1: params.token1,\n                    fee: params.feeTier,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: msg.sender,\n                    deadline: block.timestamp\n                })\n            );\n            console.log(\"New position minted - TokenId:\", _tokenId);\n        } else {\n            // Increase liquidity of existing position\n            // console.log(\"Increasing liquidity of existing position\");\n            _tokenId = params.tokenId;\n            IPositionManager(positionManager).increaseLiquidity(\n                IPositionManager.IncreaseLiquidityParams({\n                    tokenId: params.tokenId,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            // console.log(\"Liquidity increased - TokenId:\", _tokenId);\n        }\n\n        // Refund remaining tokens\n        uint256 _remaining0 = IERC20(params.token0).balanceOf(address(this));\n        uint256 _remaining1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Remaining amount0:\", _remaining0);\n        console.log(\"Remaining amount1:\", _remaining1);\n        \n        if (_remaining0 > 0) IERC20(params.token0).safeTransfer(msg.sender, _remaining0);\n        if (_remaining1 > 0) IERC20(params.token1).safeTransfer(msg.sender, _remaining1);\n        \n        console.log(\"=== swapAndAddLiquidity END ===\");\n    }\n\n    // Private functions\n\n    function _buildInputSwap(\n        uint _amountIn,\n        uint _amountOutMin,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactInputParams memory) {\n        return\n            ISwapRouter.ExactInputParams({\n                path: convertedPath(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            });\n    }\n\n    function _buildOutputSwap(\n        uint _amountInMaximum,\n        uint _amountOut,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactOutputParams memory) {\n        return\n            ISwapRouter.ExactOutputParams({\n                path: convertedPathReversed(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountOut: _amountOut,\n                amountInMaximum: _amountInMaximum\n            });\n    }\n\n    /// @notice Check if exchanging is possible or not\n    /// @dev Avoid reverting by exchange router\n    /// @return True if exchange conditions are satisfied\n    /// @return Needed amount of input token\n    function _checkExchangeConditions(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        uint256 _deadline,\n        bool _isFixedToken\n    ) private returns (bool, uint) {\n        // Check deadline has not passed\n        if (_deadline < block.timestamp) {\n            return (false, 0);\n        }\n\n        if (_isFixedToken == true) {\n            // Input amount is fixed\n            // Find maximum output amount\n            (bool success, uint outputResult) = getExactInput(_path, _inputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_outputAmount > outputResult) {\n                // Result is not enough\n                return (false, 0);\n            }\n            return (true, _inputAmount);\n        } else {\n            // Output amount is fixed\n            // Find minimum input amount\n            (bool success, uint inputResult) = getExactOutput(_path, _outputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_inputAmount < inputResult) {\n                // Input amount is not enough\n                return (false, 0);\n            }\n            return (true, inputResult);\n        }\n    }\n\n    /// @notice Execute swap to achieve optimal ratio\n    function _executeSwap(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _amountInAvailable,\n        uint256 _amountOutAvailable,\n        uint256 _targetRatio\n    ) private returns (uint256 _sentAmount, uint256 _receivedAmount) {\n        _sentAmount = _findOptimalSwapAmount(\n            _tokenIn, _tokenOut, _fee, _amountInAvailable, _amountOutAvailable, _targetRatio\n        );\n        console.log(\"Swap amount:\", _sentAmount);\n\n        console.log(\"new ratio:\", (_amountInAvailable - _sentAmount) * 1e18 / (_amountOutAvailable + _receivedAmount));\n        console.log(\"target ratio:\", _targetRatio);\n        \n        if (_sentAmount > 0) {\n            ISwapRouter.ExactInputSingleParams memory _params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _fee,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _sentAmount,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n            _receivedAmount = ISwapRouter(exchangeRouter).exactInputSingle(_params);\n        }\n    }\n\n    uint8  private constant MAX_ITERS = 20;\n\n    /// @notice Estimate how much of tokenIn to swap so that\n    ///         (in - x)/(out + y) â‰ˆ targetRatio, then refine with a capped binary search.\n    function _findOptimalSwapAmount(\n        address _tokenIn,\n        address _tokenOut,\n        uint24  _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) internal returns (uint256) {\n        if (amountIn == 0 || targetRatio == 0) return 0;\n\n        // Quick ratio check\n        if (amountOut > 0) {\n            uint256 currentRatio = (amountIn * 1e18) / amountOut;\n            if (currentRatio == targetRatio) return 0;\n        }\n\n        // Calculate initial guess\n        uint256 guess = _calculateInitialGuess(amountIn, amountOut, targetRatio);\n        console.log(\"Initial guess:\", guess);\n        \n        // Binary search with reduced variables\n        return _binarySearch(_tokenIn, _tokenOut, _fee, amountIn, amountOut, targetRatio, guess);\n    }\n\n    function _calculateInitialGuess(\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) private pure returns (uint256) {\n        if (amountOut == 0) return amountIn / 2;\n        \n        uint256 currentRatio = (amountIn * 1e18) / amountOut;\n        uint256 guess = currentRatio > targetRatio\n            ? ((currentRatio - targetRatio) * amountOut) / targetRatio\n            : ((targetRatio - currentRatio) * amountIn) / targetRatio;\n            \n        return guess > amountIn ? amountIn : guess;\n    }\n\n    function _getQuoteResult(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn\n    ) private returns (uint256 amountOut) {\n        (amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInputSingle(\n            IQuoterV2.QuoteExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: fee,\n                amountIn: amountIn,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function _binarySearch(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio,\n        uint256 guess\n    ) private returns (uint256) {\n        uint256 left = guess > amountIn/4 ? guess - amountIn/4 : 1;\n        uint256 right = guess + amountIn/4;\n        console.log(\"Left:\", left);\n        console.log(\"Right:\", right);\n        if (right > amountIn) right = amountIn;\n        console.log(\"Right after:\", right);\n\n        for (uint8 i = 0; i < MAX_ITERS && left <= right; ++i) {\n            uint256 mid = (left + right) >> 1;\n            console.log(\"Mid:\", mid);\n            \n            uint256 y = _getQuoteResult(_tokenIn, _tokenOut, _fee, mid);\n            console.log(\"Y:\", y);\n\n            if (amountOut + y == 0) {\n                right = mid - 1;\n                continue;\n            }\n            \n            uint256 newRatio = ((amountIn - mid) * 1e18) / (amountOut + y);\n            console.log(\"New ratio:\", newRatio);\n\n            if (newRatio > targetRatio) {\n                left = mid + 1;\n            } else if (newRatio < targetRatio) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n\n        return right;\n    }\n}\n","contract":"UniswapV3Connector","function":"swapAndAddLiquidity","line":468,"range":[16674,16906]},"functionType":1},{"type":0,"sourceReference":{"sourceName":"contracts/dex_connectors/UniswapV3Connector.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./DexConnectorStorage.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol\";\nimport \"./uniswap_v4_helpers/_LiquidityAmounts.sol\";\nimport \"./uniswap_v4_helpers/_TickMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n\n// Simplified interface for Uniswap V3 Position Manager\ninterface IPositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params) external payable returns (\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function positions(uint256 tokenId) external view returns (\n        uint96 nonce,\n        address operator,\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 tokensOwed0,\n        uint128 tokensOwed1\n    );\n}\n\ncontract UniswapV3Connector is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DexConnectorStorage\n{\n    modifier nonZeroAddress(address _address) {\n        require(_address != address(0), \"UniswapV3Connector: zero address\");\n        _;\n    }\n\n    using SafeERC20 for IERC20;\n\n    /// @notice This contract is used for interacting with UniswapV3 contract\n    /// @param _name Name of the underlying DEX\n    /// @param _exchangeRouter Address of the DEX router contract\n    function initialize(\n        string memory _name,\n        address _exchangeRouter,\n        address _quoterAddress\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        name = _name;\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n        quoterAddress = _quoterAddress;\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    function renounceOwnership() public virtual override onlyOwner {}\n\n    /// @notice Setter for wrapped native token\n    /// @dev Get address from exchange router\n    function setWrappedNativeToken() external override onlyOwner {\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    /// @notice Setter for exchange router\n    /// @dev Set address of liquidity pool factory from the exchange router\n    /// @param _exchangeRouter Address of the new exchange router contract\n    function setExchangeRouter(\n        address _exchangeRouter\n    ) external override nonZeroAddress(_exchangeRouter) onlyOwner {\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for liquidity pool factory\n    /// @dev Set address from exchange router\n    function setLiquidityPoolFactory() external override onlyOwner {\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for quoter\n    function setQuoter(address _quoterAddress) external onlyOwner {\n        quoterAddress = _quoterAddress;\n    }\n\n    /// @notice Setter for position manager\n    function setPositionManager(address _positionManager) external onlyOwner {\n        positionManager = _positionManager;\n    }\n\n    /// @notice Setter for fee tier\n    /// @dev We set the fee tier that is used for exchanging tokens\n    function setFeeTier(\n        address _firstToken,\n        address _secondToken,\n        uint24 _feeTier\n    ) external onlyOwner {\n        feeTier[_firstToken][_secondToken] = _feeTier;\n        feeTier[_secondToken][_firstToken] = _feeTier;\n    }\n\n    function convertedPath(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[0]);\n\n        for (uint i = 1; i < _path.length; i++) {\n            address firstToken = _path[i - 1];\n            address secondToken = _path[i];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    function convertedPathReversed(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[_path.length - 1]);\n\n        for (uint i = _path.length - 1; i > 0; i--) {\n            address firstToken = _path[i];\n            address secondToken = _path[i - 1];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    /// @notice Return the needed input amount to get the output amount\n    /// @dev Return (false, 0) if DEX cannot give the output amount. \n    ///      Note: No need to reverse the path for this function\n    function getExactOutput(\n        address[] memory _path,\n        uint256 _amountOut\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountIn, , , ) = IQuoterV2(quoterAddress).quoteExactOutput(\n            convertedPathReversed(_path),\n            _amountOut\n        );\n        return (true, amountIn);\n    }\n\n    /// @notice Return the output amount for the given input amount\n    /// @dev Return (false, 0) if DEX cannot swap the input amount\n    function getExactInput(\n        address[] memory _path,\n        uint256 _amountIn\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInput(\n            convertedPath(_path),\n            _amountIn\n        );\n        return (true, amountOut);\n    }\n\n    /// @notice Deprecated for v3\n    function getInputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Deprecated for v3\n    function getOutputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Return the square root price of given token pairs\n    function getSqrtPriceX96(\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint[] memory _sqrtPriceX96, address[] memory _firstToken)\n    {\n        address liquidityPool;\n        uint sqrtPriceX96;\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            (sqrtPriceX96, , , , , , ) = IUniswapV3PoolState(liquidityPool).slot0();\n            _sqrtPriceX96[i] = sqrtPriceX96;\n            if (IUniswapV3PoolImmutables(liquidityPool).token0() == _path[i]) {\n                _firstToken[i] = _path[i];\n            } else {\n                _firstToken[i] = _path[i + 1];\n            }\n        }\n    }\n\n    /// @notice Exchange input token for output token through exchange router\n    /// @dev Check exchange conditions before exchanging\n    ///      We assume that the input token is not WETH (it is teleBTC)\n    /// @param _inputAmount Amount of input token\n    /// @param _outputAmount Amount of output token\n    /// @param _path List of tokens that are used for exchanging\n    /// @param _to Receiver address\n    /// @param _deadline Deadline of exchanging tokens\n    /// @param _isFixedToken True if the input token amount is fixed\n    /// @return _result True if the exchange is successful\n    /// @return _amounts Amounts of tokens that are involved in exchanging\n    function swap(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        address _to,\n        uint256 _deadline,\n        bool _isFixedToken\n    )\n        external\n        override\n        nonReentrant\n        nonZeroAddress(_to)\n        returns (bool _result, uint[] memory _amounts)\n    {\n        uint neededInputAmount;\n        (_result, neededInputAmount) = _checkExchangeConditions(\n            _inputAmount,\n            _outputAmount,\n            _path,\n            _deadline,\n            _isFixedToken\n        );\n\n        if (_result) {\n            uint _amount;\n            _amounts = new uint[](2);\n            // Get tokens from user\n            IERC20(_path[0]).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                neededInputAmount\n            );\n\n            // Give allowance to exchange router\n            IERC20(_path[0]).approve(exchangeRouter, neededInputAmount);\n\n            if (_isFixedToken == true) {\n                _amount = ISwapRouter(exchangeRouter).exactInput(\n                    _buildInputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = neededInputAmount;\n                _amounts[1] = _amount;\n            }\n\n            if (_isFixedToken == false) {\n                _amount = ISwapRouter(exchangeRouter).exactOutput(\n                    _buildOutputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = _amount;\n                _amounts[1] = _outputAmount;\n            }\n            emit Swap(_path, _amounts, _to);\n        }\n    }\n\n    /// @notice Return true if the exchange path is valid\n    /// @param _path List of tokens that are used for exchanging\n    function isPathValid(\n        address[] memory _path\n    ) public view override returns (bool _result) {\n        address liquidityPool;\n\n        // Checks that path length is greater than one\n        if (_path.length < 2) {\n            return false;\n        }\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            if (liquidityPool == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    struct AddLiquidityParams {\n        uint256 tokenId; // 0 for new position, non-zero for existing position\n        address token0;\n        address token1;\n        uint24 feeTier;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n    }\n\n    /// @notice Zap tokens into a Uniswap V3 position in one call\n    function swapAndAddLiquidity(\n        AddLiquidityParams memory params\n    ) external nonReentrant returns (\n        uint256 _tokenId,\n        uint256 _used0,\n        uint256 _used1\n    ) {\n        // console.log(\"=== swapAndAddLiquidity START ===\");\n        // console.log(\"Position manager:\", positionManager);\n        // console.log(\"Token0:\", params.token0);\n        // console.log(\"Token1:\", params.token1);\n        // console.log(\"TokenId:\", params.tokenId);\n        // console.log(\"Amount0Desired:\", params.amount0Desired);\n        // console.log(\"Amount1Desired:\", params.amount1Desired);\n        // console.logInt(params.tickLower);\n        // console.logInt(params.tickUpper);\n        \n        // require(params.amount0Desired > 0 && params.amount1Desired > 0, \"Zero amounts\");\n\n        console.log(\"Basic validations passed\");\n\n        // If tokenId is non-zero, validate existing position parameters\n        if (params.tokenId != 0) {\n            // console.log(\"Validating existing position parameters\");\n            (\n                , , , , \n                uint24 existingFee,\n                int24 existingTickLower,\n                int24 existingTickUpper,\n                , , , , \n            ) = IPositionManager(positionManager).positions(params.tokenId);\n            \n            // console.log(\"Existing fee:\", existingFee);\n            // console.logInt(existingTickLower);\n            // console.logInt(existingTickUpper);\n            \n            require(existingFee == params.feeTier, \"Fee tier mismatch\");\n            require(existingTickLower == params.tickLower, \"Tick lower mismatch\");\n            require(existingTickUpper == params.tickUpper, \"Tick upper mismatch\");\n            // console.log(\"Existing position validation passed\");\n        }\n\n        // console.log(\"Starting token transfers and approvals\");\n\n        // 1) Pull in tokens and approve\n        IERC20(params.token0).safeTransferFrom(msg.sender, address(this), params.amount0Desired);\n        IERC20(params.token1).safeTransferFrom(msg.sender, address(this), params.amount1Desired);\n        IERC20(params.token0).approve(exchangeRouter, params.amount0Desired);\n        IERC20(params.token1).approve(exchangeRouter, params.amount1Desired);\n        IERC20(params.token0).approve(positionManager, type(uint256).max);\n        IERC20(params.token1).approve(positionManager, type(uint256).max);\n\n        console.log(\"Token transfers and approvals completed\");\n\n        \n        // Get current sqrt price from the pool\n        // console.log(\"Getting pool and sqrt price\");\n        address poolAddress = IUniswapV3Factory(liquidityPoolFactory).getPool(\n            params.token0, \n            params.token1, \n            params.feeTier\n        );\n        console.log(\"Pool address:\", poolAddress);\n        \n        (uint160 _sqrtP, , , , , , ) = IUniswapV3PoolState(poolAddress).slot0();\n        console.log(\"Current sqrt price:\", _sqrtP);\n\n        // Calculate the maximum liquidity that can be provided with the given token amounts\n        console.log(\"Calculating liquidity amounts\");\n        uint128 _maxLiquidity = _LiquidityAmounts.getLiquidityForAmounts(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            params.amount0Desired,\n            params.amount1Desired\n        );\n        console.log(\"Max liquidity:\", _maxLiquidity);\n\n        // Then get the optimal amounts for that liquidity\n        (uint256 _optimalAmount0, uint256 _optimalAmount1) = _LiquidityAmounts.getAmountsForLiquidity(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            _maxLiquidity\n        );\n        console.log(\"Optimal amount0:\", _optimalAmount0);\n        console.log(\"Optimal amount1:\", _optimalAmount1);\n\n        // 3) Execute swap if needed\n        uint256 _rangeRatio = _optimalAmount1 > 0 \n            ? (_optimalAmount0 * 1e18) / _optimalAmount1 \n            : 1e18;\n        uint256 _currentRatio = params.amount1Desired > 0 \n            ? (params.amount0Desired * 1e18) / params.amount1Desired \n            : type(uint256).max;\n        \n        console.log(\"Range ratio:\", _rangeRatio);\n        console.log(\"Current ratio:\", _currentRatio);\n        \n        if (_currentRatio > _rangeRatio) {\n            console.log(\"Executing swap: token0 -> token1\");\n            _executeSwap(\n                params.token0, \n                params.token1, \n                params.feeTier, \n                params.amount0Desired, \n                params.amount1Desired, \n                _rangeRatio\n            );\n        } else if (_currentRatio < _rangeRatio && _rangeRatio > 0) {\n            console.log(\"Executing swap: token1 -> token0\");\n            _executeSwap(\n                params.token1, \n                params.token0, \n                params.feeTier, \n                params.amount1Desired, \n                params.amount0Desired, \n                1e18 / _rangeRatio\n            );\n        } else {\n            // console.log(\"No swap needed\");\n        }\n\n        // 4) Mint position or increase liquidity and refund\n        _used0 = IERC20(params.token0).balanceOf(address(this));\n        _used1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Used amount0:\", _used0);\n        console.log(\"Used amount1:\", _used1);\n\n        if (params.tokenId == 0) {\n            // Mint new position\n            console.log(\"Minting new position\");\n            (_tokenId, , , ) = IPositionManager(positionManager).mint(\n                IPositionManager.MintParams({\n                    token0: params.token0,\n                    token1: params.token1,\n                    fee: params.feeTier,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: msg.sender,\n                    deadline: block.timestamp\n                })\n            );\n            console.log(\"New position minted - TokenId:\", _tokenId);\n        } else {\n            // Increase liquidity of existing position\n            // console.log(\"Increasing liquidity of existing position\");\n            _tokenId = params.tokenId;\n            IPositionManager(positionManager).increaseLiquidity(\n                IPositionManager.IncreaseLiquidityParams({\n                    tokenId: params.tokenId,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            // console.log(\"Liquidity increased - TokenId:\", _tokenId);\n        }\n\n        // Refund remaining tokens\n        uint256 _remaining0 = IERC20(params.token0).balanceOf(address(this));\n        uint256 _remaining1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Remaining amount0:\", _remaining0);\n        console.log(\"Remaining amount1:\", _remaining1);\n        \n        if (_remaining0 > 0) IERC20(params.token0).safeTransfer(msg.sender, _remaining0);\n        if (_remaining1 > 0) IERC20(params.token1).safeTransfer(msg.sender, _remaining1);\n        \n        console.log(\"=== swapAndAddLiquidity END ===\");\n    }\n\n    // Private functions\n\n    function _buildInputSwap(\n        uint _amountIn,\n        uint _amountOutMin,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactInputParams memory) {\n        return\n            ISwapRouter.ExactInputParams({\n                path: convertedPath(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            });\n    }\n\n    function _buildOutputSwap(\n        uint _amountInMaximum,\n        uint _amountOut,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactOutputParams memory) {\n        return\n            ISwapRouter.ExactOutputParams({\n                path: convertedPathReversed(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountOut: _amountOut,\n                amountInMaximum: _amountInMaximum\n            });\n    }\n\n    /// @notice Check if exchanging is possible or not\n    /// @dev Avoid reverting by exchange router\n    /// @return True if exchange conditions are satisfied\n    /// @return Needed amount of input token\n    function _checkExchangeConditions(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        uint256 _deadline,\n        bool _isFixedToken\n    ) private returns (bool, uint) {\n        // Check deadline has not passed\n        if (_deadline < block.timestamp) {\n            return (false, 0);\n        }\n\n        if (_isFixedToken == true) {\n            // Input amount is fixed\n            // Find maximum output amount\n            (bool success, uint outputResult) = getExactInput(_path, _inputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_outputAmount > outputResult) {\n                // Result is not enough\n                return (false, 0);\n            }\n            return (true, _inputAmount);\n        } else {\n            // Output amount is fixed\n            // Find minimum input amount\n            (bool success, uint inputResult) = getExactOutput(_path, _outputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_inputAmount < inputResult) {\n                // Input amount is not enough\n                return (false, 0);\n            }\n            return (true, inputResult);\n        }\n    }\n\n    /// @notice Execute swap to achieve optimal ratio\n    function _executeSwap(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _amountInAvailable,\n        uint256 _amountOutAvailable,\n        uint256 _targetRatio\n    ) private returns (uint256 _sentAmount, uint256 _receivedAmount) {\n        _sentAmount = _findOptimalSwapAmount(\n            _tokenIn, _tokenOut, _fee, _amountInAvailable, _amountOutAvailable, _targetRatio\n        );\n        console.log(\"Swap amount:\", _sentAmount);\n\n        console.log(\"new ratio:\", (_amountInAvailable - _sentAmount) * 1e18 / (_amountOutAvailable + _receivedAmount));\n        console.log(\"target ratio:\", _targetRatio);\n        \n        if (_sentAmount > 0) {\n            ISwapRouter.ExactInputSingleParams memory _params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _fee,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _sentAmount,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n            _receivedAmount = ISwapRouter(exchangeRouter).exactInputSingle(_params);\n        }\n    }\n\n    uint8  private constant MAX_ITERS = 20;\n\n    /// @notice Estimate how much of tokenIn to swap so that\n    ///         (in - x)/(out + y) â‰ˆ targetRatio, then refine with a capped binary search.\n    function _findOptimalSwapAmount(\n        address _tokenIn,\n        address _tokenOut,\n        uint24  _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) internal returns (uint256) {\n        if (amountIn == 0 || targetRatio == 0) return 0;\n\n        // Quick ratio check\n        if (amountOut > 0) {\n            uint256 currentRatio = (amountIn * 1e18) / amountOut;\n            if (currentRatio == targetRatio) return 0;\n        }\n\n        // Calculate initial guess\n        uint256 guess = _calculateInitialGuess(amountIn, amountOut, targetRatio);\n        console.log(\"Initial guess:\", guess);\n        \n        // Binary search with reduced variables\n        return _binarySearch(_tokenIn, _tokenOut, _fee, amountIn, amountOut, targetRatio, guess);\n    }\n\n    function _calculateInitialGuess(\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) private pure returns (uint256) {\n        if (amountOut == 0) return amountIn / 2;\n        \n        uint256 currentRatio = (amountIn * 1e18) / amountOut;\n        uint256 guess = currentRatio > targetRatio\n            ? ((currentRatio - targetRatio) * amountOut) / targetRatio\n            : ((targetRatio - currentRatio) * amountIn) / targetRatio;\n            \n        return guess > amountIn ? amountIn : guess;\n    }\n\n    function _getQuoteResult(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn\n    ) private returns (uint256 amountOut) {\n        (amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInputSingle(\n            IQuoterV2.QuoteExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: fee,\n                amountIn: amountIn,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function _binarySearch(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio,\n        uint256 guess\n    ) private returns (uint256) {\n        uint256 left = guess > amountIn/4 ? guess - amountIn/4 : 1;\n        uint256 right = guess + amountIn/4;\n        console.log(\"Left:\", left);\n        console.log(\"Right:\", right);\n        if (right > amountIn) right = amountIn;\n        console.log(\"Right after:\", right);\n\n        for (uint8 i = 0; i < MAX_ITERS && left <= right; ++i) {\n            uint256 mid = (left + right) >> 1;\n            console.log(\"Mid:\", mid);\n            \n            uint256 y = _getQuoteResult(_tokenIn, _tokenOut, _fee, mid);\n            console.log(\"Y:\", y);\n\n            if (amountOut + y == 0) {\n                right = mid - 1;\n                continue;\n            }\n            \n            uint256 newRatio = ((amountIn - mid) * 1e18) / (amountOut + y);\n            console.log(\"New ratio:\", newRatio);\n\n            if (newRatio > targetRatio) {\n                left = mid + 1;\n            } else if (newRatio < targetRatio) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n\n        return right;\n    }\n}\n","contract":"UniswapV3Connector","function":"_executeSwap","line":632,"range":[22609,22735]},"functionType":1},{"type":0,"sourceReference":{"sourceName":"contracts/dex_connectors/UniswapV3Connector.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./DexConnectorStorage.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol\";\nimport \"./uniswap_v4_helpers/_LiquidityAmounts.sol\";\nimport \"./uniswap_v4_helpers/_TickMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n\n// Simplified interface for Uniswap V3 Position Manager\ninterface IPositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params) external payable returns (\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function positions(uint256 tokenId) external view returns (\n        uint96 nonce,\n        address operator,\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 tokensOwed0,\n        uint128 tokensOwed1\n    );\n}\n\ncontract UniswapV3Connector is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DexConnectorStorage\n{\n    modifier nonZeroAddress(address _address) {\n        require(_address != address(0), \"UniswapV3Connector: zero address\");\n        _;\n    }\n\n    using SafeERC20 for IERC20;\n\n    /// @notice This contract is used for interacting with UniswapV3 contract\n    /// @param _name Name of the underlying DEX\n    /// @param _exchangeRouter Address of the DEX router contract\n    function initialize(\n        string memory _name,\n        address _exchangeRouter,\n        address _quoterAddress\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        name = _name;\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n        quoterAddress = _quoterAddress;\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    function renounceOwnership() public virtual override onlyOwner {}\n\n    /// @notice Setter for wrapped native token\n    /// @dev Get address from exchange router\n    function setWrappedNativeToken() external override onlyOwner {\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    /// @notice Setter for exchange router\n    /// @dev Set address of liquidity pool factory from the exchange router\n    /// @param _exchangeRouter Address of the new exchange router contract\n    function setExchangeRouter(\n        address _exchangeRouter\n    ) external override nonZeroAddress(_exchangeRouter) onlyOwner {\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for liquidity pool factory\n    /// @dev Set address from exchange router\n    function setLiquidityPoolFactory() external override onlyOwner {\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for quoter\n    function setQuoter(address _quoterAddress) external onlyOwner {\n        quoterAddress = _quoterAddress;\n    }\n\n    /// @notice Setter for position manager\n    function setPositionManager(address _positionManager) external onlyOwner {\n        positionManager = _positionManager;\n    }\n\n    /// @notice Setter for fee tier\n    /// @dev We set the fee tier that is used for exchanging tokens\n    function setFeeTier(\n        address _firstToken,\n        address _secondToken,\n        uint24 _feeTier\n    ) external onlyOwner {\n        feeTier[_firstToken][_secondToken] = _feeTier;\n        feeTier[_secondToken][_firstToken] = _feeTier;\n    }\n\n    function convertedPath(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[0]);\n\n        for (uint i = 1; i < _path.length; i++) {\n            address firstToken = _path[i - 1];\n            address secondToken = _path[i];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    function convertedPathReversed(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[_path.length - 1]);\n\n        for (uint i = _path.length - 1; i > 0; i--) {\n            address firstToken = _path[i];\n            address secondToken = _path[i - 1];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    /// @notice Return the needed input amount to get the output amount\n    /// @dev Return (false, 0) if DEX cannot give the output amount. \n    ///      Note: No need to reverse the path for this function\n    function getExactOutput(\n        address[] memory _path,\n        uint256 _amountOut\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountIn, , , ) = IQuoterV2(quoterAddress).quoteExactOutput(\n            convertedPathReversed(_path),\n            _amountOut\n        );\n        return (true, amountIn);\n    }\n\n    /// @notice Return the output amount for the given input amount\n    /// @dev Return (false, 0) if DEX cannot swap the input amount\n    function getExactInput(\n        address[] memory _path,\n        uint256 _amountIn\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInput(\n            convertedPath(_path),\n            _amountIn\n        );\n        return (true, amountOut);\n    }\n\n    /// @notice Deprecated for v3\n    function getInputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Deprecated for v3\n    function getOutputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Return the square root price of given token pairs\n    function getSqrtPriceX96(\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint[] memory _sqrtPriceX96, address[] memory _firstToken)\n    {\n        address liquidityPool;\n        uint sqrtPriceX96;\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            (sqrtPriceX96, , , , , , ) = IUniswapV3PoolState(liquidityPool).slot0();\n            _sqrtPriceX96[i] = sqrtPriceX96;\n            if (IUniswapV3PoolImmutables(liquidityPool).token0() == _path[i]) {\n                _firstToken[i] = _path[i];\n            } else {\n                _firstToken[i] = _path[i + 1];\n            }\n        }\n    }\n\n    /// @notice Exchange input token for output token through exchange router\n    /// @dev Check exchange conditions before exchanging\n    ///      We assume that the input token is not WETH (it is teleBTC)\n    /// @param _inputAmount Amount of input token\n    /// @param _outputAmount Amount of output token\n    /// @param _path List of tokens that are used for exchanging\n    /// @param _to Receiver address\n    /// @param _deadline Deadline of exchanging tokens\n    /// @param _isFixedToken True if the input token amount is fixed\n    /// @return _result True if the exchange is successful\n    /// @return _amounts Amounts of tokens that are involved in exchanging\n    function swap(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        address _to,\n        uint256 _deadline,\n        bool _isFixedToken\n    )\n        external\n        override\n        nonReentrant\n        nonZeroAddress(_to)\n        returns (bool _result, uint[] memory _amounts)\n    {\n        uint neededInputAmount;\n        (_result, neededInputAmount) = _checkExchangeConditions(\n            _inputAmount,\n            _outputAmount,\n            _path,\n            _deadline,\n            _isFixedToken\n        );\n\n        if (_result) {\n            uint _amount;\n            _amounts = new uint[](2);\n            // Get tokens from user\n            IERC20(_path[0]).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                neededInputAmount\n            );\n\n            // Give allowance to exchange router\n            IERC20(_path[0]).approve(exchangeRouter, neededInputAmount);\n\n            if (_isFixedToken == true) {\n                _amount = ISwapRouter(exchangeRouter).exactInput(\n                    _buildInputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = neededInputAmount;\n                _amounts[1] = _amount;\n            }\n\n            if (_isFixedToken == false) {\n                _amount = ISwapRouter(exchangeRouter).exactOutput(\n                    _buildOutputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = _amount;\n                _amounts[1] = _outputAmount;\n            }\n            emit Swap(_path, _amounts, _to);\n        }\n    }\n\n    /// @notice Return true if the exchange path is valid\n    /// @param _path List of tokens that are used for exchanging\n    function isPathValid(\n        address[] memory _path\n    ) public view override returns (bool _result) {\n        address liquidityPool;\n\n        // Checks that path length is greater than one\n        if (_path.length < 2) {\n            return false;\n        }\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            if (liquidityPool == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    struct AddLiquidityParams {\n        uint256 tokenId; // 0 for new position, non-zero for existing position\n        address token0;\n        address token1;\n        uint24 feeTier;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n    }\n\n    /// @notice Zap tokens into a Uniswap V3 position in one call\n    function swapAndAddLiquidity(\n        AddLiquidityParams memory params\n    ) external nonReentrant returns (\n        uint256 _tokenId,\n        uint256 _used0,\n        uint256 _used1\n    ) {\n        // console.log(\"=== swapAndAddLiquidity START ===\");\n        // console.log(\"Position manager:\", positionManager);\n        // console.log(\"Token0:\", params.token0);\n        // console.log(\"Token1:\", params.token1);\n        // console.log(\"TokenId:\", params.tokenId);\n        // console.log(\"Amount0Desired:\", params.amount0Desired);\n        // console.log(\"Amount1Desired:\", params.amount1Desired);\n        // console.logInt(params.tickLower);\n        // console.logInt(params.tickUpper);\n        \n        // require(params.amount0Desired > 0 && params.amount1Desired > 0, \"Zero amounts\");\n\n        console.log(\"Basic validations passed\");\n\n        // If tokenId is non-zero, validate existing position parameters\n        if (params.tokenId != 0) {\n            // console.log(\"Validating existing position parameters\");\n            (\n                , , , , \n                uint24 existingFee,\n                int24 existingTickLower,\n                int24 existingTickUpper,\n                , , , , \n            ) = IPositionManager(positionManager).positions(params.tokenId);\n            \n            // console.log(\"Existing fee:\", existingFee);\n            // console.logInt(existingTickLower);\n            // console.logInt(existingTickUpper);\n            \n            require(existingFee == params.feeTier, \"Fee tier mismatch\");\n            require(existingTickLower == params.tickLower, \"Tick lower mismatch\");\n            require(existingTickUpper == params.tickUpper, \"Tick upper mismatch\");\n            // console.log(\"Existing position validation passed\");\n        }\n\n        // console.log(\"Starting token transfers and approvals\");\n\n        // 1) Pull in tokens and approve\n        IERC20(params.token0).safeTransferFrom(msg.sender, address(this), params.amount0Desired);\n        IERC20(params.token1).safeTransferFrom(msg.sender, address(this), params.amount1Desired);\n        IERC20(params.token0).approve(exchangeRouter, params.amount0Desired);\n        IERC20(params.token1).approve(exchangeRouter, params.amount1Desired);\n        IERC20(params.token0).approve(positionManager, type(uint256).max);\n        IERC20(params.token1).approve(positionManager, type(uint256).max);\n\n        console.log(\"Token transfers and approvals completed\");\n\n        \n        // Get current sqrt price from the pool\n        // console.log(\"Getting pool and sqrt price\");\n        address poolAddress = IUniswapV3Factory(liquidityPoolFactory).getPool(\n            params.token0, \n            params.token1, \n            params.feeTier\n        );\n        console.log(\"Pool address:\", poolAddress);\n        \n        (uint160 _sqrtP, , , , , , ) = IUniswapV3PoolState(poolAddress).slot0();\n        console.log(\"Current sqrt price:\", _sqrtP);\n\n        // Calculate the maximum liquidity that can be provided with the given token amounts\n        console.log(\"Calculating liquidity amounts\");\n        uint128 _maxLiquidity = _LiquidityAmounts.getLiquidityForAmounts(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            params.amount0Desired,\n            params.amount1Desired\n        );\n        console.log(\"Max liquidity:\", _maxLiquidity);\n\n        // Then get the optimal amounts for that liquidity\n        (uint256 _optimalAmount0, uint256 _optimalAmount1) = _LiquidityAmounts.getAmountsForLiquidity(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            _maxLiquidity\n        );\n        console.log(\"Optimal amount0:\", _optimalAmount0);\n        console.log(\"Optimal amount1:\", _optimalAmount1);\n\n        // 3) Execute swap if needed\n        uint256 _rangeRatio = _optimalAmount1 > 0 \n            ? (_optimalAmount0 * 1e18) / _optimalAmount1 \n            : 1e18;\n        uint256 _currentRatio = params.amount1Desired > 0 \n            ? (params.amount0Desired * 1e18) / params.amount1Desired \n            : type(uint256).max;\n        \n        console.log(\"Range ratio:\", _rangeRatio);\n        console.log(\"Current ratio:\", _currentRatio);\n        \n        if (_currentRatio > _rangeRatio) {\n            console.log(\"Executing swap: token0 -> token1\");\n            _executeSwap(\n                params.token0, \n                params.token1, \n                params.feeTier, \n                params.amount0Desired, \n                params.amount1Desired, \n                _rangeRatio\n            );\n        } else if (_currentRatio < _rangeRatio && _rangeRatio > 0) {\n            console.log(\"Executing swap: token1 -> token0\");\n            _executeSwap(\n                params.token1, \n                params.token0, \n                params.feeTier, \n                params.amount1Desired, \n                params.amount0Desired, \n                1e18 / _rangeRatio\n            );\n        } else {\n            // console.log(\"No swap needed\");\n        }\n\n        // 4) Mint position or increase liquidity and refund\n        _used0 = IERC20(params.token0).balanceOf(address(this));\n        _used1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Used amount0:\", _used0);\n        console.log(\"Used amount1:\", _used1);\n\n        if (params.tokenId == 0) {\n            // Mint new position\n            console.log(\"Minting new position\");\n            (_tokenId, , , ) = IPositionManager(positionManager).mint(\n                IPositionManager.MintParams({\n                    token0: params.token0,\n                    token1: params.token1,\n                    fee: params.feeTier,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: msg.sender,\n                    deadline: block.timestamp\n                })\n            );\n            console.log(\"New position minted - TokenId:\", _tokenId);\n        } else {\n            // Increase liquidity of existing position\n            // console.log(\"Increasing liquidity of existing position\");\n            _tokenId = params.tokenId;\n            IPositionManager(positionManager).increaseLiquidity(\n                IPositionManager.IncreaseLiquidityParams({\n                    tokenId: params.tokenId,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            // console.log(\"Liquidity increased - TokenId:\", _tokenId);\n        }\n\n        // Refund remaining tokens\n        uint256 _remaining0 = IERC20(params.token0).balanceOf(address(this));\n        uint256 _remaining1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Remaining amount0:\", _remaining0);\n        console.log(\"Remaining amount1:\", _remaining1);\n        \n        if (_remaining0 > 0) IERC20(params.token0).safeTransfer(msg.sender, _remaining0);\n        if (_remaining1 > 0) IERC20(params.token1).safeTransfer(msg.sender, _remaining1);\n        \n        console.log(\"=== swapAndAddLiquidity END ===\");\n    }\n\n    // Private functions\n\n    function _buildInputSwap(\n        uint _amountIn,\n        uint _amountOutMin,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactInputParams memory) {\n        return\n            ISwapRouter.ExactInputParams({\n                path: convertedPath(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            });\n    }\n\n    function _buildOutputSwap(\n        uint _amountInMaximum,\n        uint _amountOut,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactOutputParams memory) {\n        return\n            ISwapRouter.ExactOutputParams({\n                path: convertedPathReversed(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountOut: _amountOut,\n                amountInMaximum: _amountInMaximum\n            });\n    }\n\n    /// @notice Check if exchanging is possible or not\n    /// @dev Avoid reverting by exchange router\n    /// @return True if exchange conditions are satisfied\n    /// @return Needed amount of input token\n    function _checkExchangeConditions(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        uint256 _deadline,\n        bool _isFixedToken\n    ) private returns (bool, uint) {\n        // Check deadline has not passed\n        if (_deadline < block.timestamp) {\n            return (false, 0);\n        }\n\n        if (_isFixedToken == true) {\n            // Input amount is fixed\n            // Find maximum output amount\n            (bool success, uint outputResult) = getExactInput(_path, _inputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_outputAmount > outputResult) {\n                // Result is not enough\n                return (false, 0);\n            }\n            return (true, _inputAmount);\n        } else {\n            // Output amount is fixed\n            // Find minimum input amount\n            (bool success, uint inputResult) = getExactOutput(_path, _outputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_inputAmount < inputResult) {\n                // Input amount is not enough\n                return (false, 0);\n            }\n            return (true, inputResult);\n        }\n    }\n\n    /// @notice Execute swap to achieve optimal ratio\n    function _executeSwap(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _amountInAvailable,\n        uint256 _amountOutAvailable,\n        uint256 _targetRatio\n    ) private returns (uint256 _sentAmount, uint256 _receivedAmount) {\n        _sentAmount = _findOptimalSwapAmount(\n            _tokenIn, _tokenOut, _fee, _amountInAvailable, _amountOutAvailable, _targetRatio\n        );\n        console.log(\"Swap amount:\", _sentAmount);\n\n        console.log(\"new ratio:\", (_amountInAvailable - _sentAmount) * 1e18 / (_amountOutAvailable + _receivedAmount));\n        console.log(\"target ratio:\", _targetRatio);\n        \n        if (_sentAmount > 0) {\n            ISwapRouter.ExactInputSingleParams memory _params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _fee,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _sentAmount,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n            _receivedAmount = ISwapRouter(exchangeRouter).exactInputSingle(_params);\n        }\n    }\n\n    uint8  private constant MAX_ITERS = 20;\n\n    /// @notice Estimate how much of tokenIn to swap so that\n    ///         (in - x)/(out + y) â‰ˆ targetRatio, then refine with a capped binary search.\n    function _findOptimalSwapAmount(\n        address _tokenIn,\n        address _tokenOut,\n        uint24  _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) internal returns (uint256) {\n        if (amountIn == 0 || targetRatio == 0) return 0;\n\n        // Quick ratio check\n        if (amountOut > 0) {\n            uint256 currentRatio = (amountIn * 1e18) / amountOut;\n            if (currentRatio == targetRatio) return 0;\n        }\n\n        // Calculate initial guess\n        uint256 guess = _calculateInitialGuess(amountIn, amountOut, targetRatio);\n        console.log(\"Initial guess:\", guess);\n        \n        // Binary search with reduced variables\n        return _binarySearch(_tokenIn, _tokenOut, _fee, amountIn, amountOut, targetRatio, guess);\n    }\n\n    function _calculateInitialGuess(\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) private pure returns (uint256) {\n        if (amountOut == 0) return amountIn / 2;\n        \n        uint256 currentRatio = (amountIn * 1e18) / amountOut;\n        uint256 guess = currentRatio > targetRatio\n            ? ((currentRatio - targetRatio) * amountOut) / targetRatio\n            : ((targetRatio - currentRatio) * amountIn) / targetRatio;\n            \n        return guess > amountIn ? amountIn : guess;\n    }\n\n    function _getQuoteResult(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn\n    ) private returns (uint256 amountOut) {\n        (amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInputSingle(\n            IQuoterV2.QuoteExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: fee,\n                amountIn: amountIn,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function _binarySearch(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio,\n        uint256 guess\n    ) private returns (uint256) {\n        uint256 left = guess > amountIn/4 ? guess - amountIn/4 : 1;\n        uint256 right = guess + amountIn/4;\n        console.log(\"Left:\", left);\n        console.log(\"Right:\", right);\n        if (right > amountIn) right = amountIn;\n        console.log(\"Right after:\", right);\n\n        for (uint8 i = 0; i < MAX_ITERS && left <= right; ++i) {\n            uint256 mid = (left + right) >> 1;\n            console.log(\"Mid:\", mid);\n            \n            uint256 y = _getQuoteResult(_tokenIn, _tokenOut, _fee, mid);\n            console.log(\"Y:\", y);\n\n            if (amountOut + y == 0) {\n                right = mid - 1;\n                continue;\n            }\n            \n            uint256 newRatio = ((amountIn - mid) * 1e18) / (amountOut + y);\n            console.log(\"New ratio:\", newRatio);\n\n            if (newRatio > targetRatio) {\n                left = mid + 1;\n            } else if (newRatio < targetRatio) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n\n        return right;\n    }\n}\n","contract":"UniswapV3Connector","function":"_findOptimalSwapAmount","line":680,"range":[24426,24507]},"functionType":1},{"type":0,"sourceReference":{"sourceName":"contracts/dex_connectors/UniswapV3Connector.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./DexConnectorStorage.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol\";\nimport \"./uniswap_v4_helpers/_LiquidityAmounts.sol\";\nimport \"./uniswap_v4_helpers/_TickMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n\n// Simplified interface for Uniswap V3 Position Manager\ninterface IPositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params) external payable returns (\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function positions(uint256 tokenId) external view returns (\n        uint96 nonce,\n        address operator,\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 tokensOwed0,\n        uint128 tokensOwed1\n    );\n}\n\ncontract UniswapV3Connector is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DexConnectorStorage\n{\n    modifier nonZeroAddress(address _address) {\n        require(_address != address(0), \"UniswapV3Connector: zero address\");\n        _;\n    }\n\n    using SafeERC20 for IERC20;\n\n    /// @notice This contract is used for interacting with UniswapV3 contract\n    /// @param _name Name of the underlying DEX\n    /// @param _exchangeRouter Address of the DEX router contract\n    function initialize(\n        string memory _name,\n        address _exchangeRouter,\n        address _quoterAddress\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        name = _name;\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n        quoterAddress = _quoterAddress;\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    function renounceOwnership() public virtual override onlyOwner {}\n\n    /// @notice Setter for wrapped native token\n    /// @dev Get address from exchange router\n    function setWrappedNativeToken() external override onlyOwner {\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    /// @notice Setter for exchange router\n    /// @dev Set address of liquidity pool factory from the exchange router\n    /// @param _exchangeRouter Address of the new exchange router contract\n    function setExchangeRouter(\n        address _exchangeRouter\n    ) external override nonZeroAddress(_exchangeRouter) onlyOwner {\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for liquidity pool factory\n    /// @dev Set address from exchange router\n    function setLiquidityPoolFactory() external override onlyOwner {\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for quoter\n    function setQuoter(address _quoterAddress) external onlyOwner {\n        quoterAddress = _quoterAddress;\n    }\n\n    /// @notice Setter for position manager\n    function setPositionManager(address _positionManager) external onlyOwner {\n        positionManager = _positionManager;\n    }\n\n    /// @notice Setter for fee tier\n    /// @dev We set the fee tier that is used for exchanging tokens\n    function setFeeTier(\n        address _firstToken,\n        address _secondToken,\n        uint24 _feeTier\n    ) external onlyOwner {\n        feeTier[_firstToken][_secondToken] = _feeTier;\n        feeTier[_secondToken][_firstToken] = _feeTier;\n    }\n\n    function convertedPath(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[0]);\n\n        for (uint i = 1; i < _path.length; i++) {\n            address firstToken = _path[i - 1];\n            address secondToken = _path[i];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    function convertedPathReversed(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[_path.length - 1]);\n\n        for (uint i = _path.length - 1; i > 0; i--) {\n            address firstToken = _path[i];\n            address secondToken = _path[i - 1];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    /// @notice Return the needed input amount to get the output amount\n    /// @dev Return (false, 0) if DEX cannot give the output amount. \n    ///      Note: No need to reverse the path for this function\n    function getExactOutput(\n        address[] memory _path,\n        uint256 _amountOut\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountIn, , , ) = IQuoterV2(quoterAddress).quoteExactOutput(\n            convertedPathReversed(_path),\n            _amountOut\n        );\n        return (true, amountIn);\n    }\n\n    /// @notice Return the output amount for the given input amount\n    /// @dev Return (false, 0) if DEX cannot swap the input amount\n    function getExactInput(\n        address[] memory _path,\n        uint256 _amountIn\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInput(\n            convertedPath(_path),\n            _amountIn\n        );\n        return (true, amountOut);\n    }\n\n    /// @notice Deprecated for v3\n    function getInputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Deprecated for v3\n    function getOutputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Return the square root price of given token pairs\n    function getSqrtPriceX96(\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint[] memory _sqrtPriceX96, address[] memory _firstToken)\n    {\n        address liquidityPool;\n        uint sqrtPriceX96;\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            (sqrtPriceX96, , , , , , ) = IUniswapV3PoolState(liquidityPool).slot0();\n            _sqrtPriceX96[i] = sqrtPriceX96;\n            if (IUniswapV3PoolImmutables(liquidityPool).token0() == _path[i]) {\n                _firstToken[i] = _path[i];\n            } else {\n                _firstToken[i] = _path[i + 1];\n            }\n        }\n    }\n\n    /// @notice Exchange input token for output token through exchange router\n    /// @dev Check exchange conditions before exchanging\n    ///      We assume that the input token is not WETH (it is teleBTC)\n    /// @param _inputAmount Amount of input token\n    /// @param _outputAmount Amount of output token\n    /// @param _path List of tokens that are used for exchanging\n    /// @param _to Receiver address\n    /// @param _deadline Deadline of exchanging tokens\n    /// @param _isFixedToken True if the input token amount is fixed\n    /// @return _result True if the exchange is successful\n    /// @return _amounts Amounts of tokens that are involved in exchanging\n    function swap(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        address _to,\n        uint256 _deadline,\n        bool _isFixedToken\n    )\n        external\n        override\n        nonReentrant\n        nonZeroAddress(_to)\n        returns (bool _result, uint[] memory _amounts)\n    {\n        uint neededInputAmount;\n        (_result, neededInputAmount) = _checkExchangeConditions(\n            _inputAmount,\n            _outputAmount,\n            _path,\n            _deadline,\n            _isFixedToken\n        );\n\n        if (_result) {\n            uint _amount;\n            _amounts = new uint[](2);\n            // Get tokens from user\n            IERC20(_path[0]).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                neededInputAmount\n            );\n\n            // Give allowance to exchange router\n            IERC20(_path[0]).approve(exchangeRouter, neededInputAmount);\n\n            if (_isFixedToken == true) {\n                _amount = ISwapRouter(exchangeRouter).exactInput(\n                    _buildInputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = neededInputAmount;\n                _amounts[1] = _amount;\n            }\n\n            if (_isFixedToken == false) {\n                _amount = ISwapRouter(exchangeRouter).exactOutput(\n                    _buildOutputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = _amount;\n                _amounts[1] = _outputAmount;\n            }\n            emit Swap(_path, _amounts, _to);\n        }\n    }\n\n    /// @notice Return true if the exchange path is valid\n    /// @param _path List of tokens that are used for exchanging\n    function isPathValid(\n        address[] memory _path\n    ) public view override returns (bool _result) {\n        address liquidityPool;\n\n        // Checks that path length is greater than one\n        if (_path.length < 2) {\n            return false;\n        }\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            if (liquidityPool == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    struct AddLiquidityParams {\n        uint256 tokenId; // 0 for new position, non-zero for existing position\n        address token0;\n        address token1;\n        uint24 feeTier;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n    }\n\n    /// @notice Zap tokens into a Uniswap V3 position in one call\n    function swapAndAddLiquidity(\n        AddLiquidityParams memory params\n    ) external nonReentrant returns (\n        uint256 _tokenId,\n        uint256 _used0,\n        uint256 _used1\n    ) {\n        // console.log(\"=== swapAndAddLiquidity START ===\");\n        // console.log(\"Position manager:\", positionManager);\n        // console.log(\"Token0:\", params.token0);\n        // console.log(\"Token1:\", params.token1);\n        // console.log(\"TokenId:\", params.tokenId);\n        // console.log(\"Amount0Desired:\", params.amount0Desired);\n        // console.log(\"Amount1Desired:\", params.amount1Desired);\n        // console.logInt(params.tickLower);\n        // console.logInt(params.tickUpper);\n        \n        // require(params.amount0Desired > 0 && params.amount1Desired > 0, \"Zero amounts\");\n\n        console.log(\"Basic validations passed\");\n\n        // If tokenId is non-zero, validate existing position parameters\n        if (params.tokenId != 0) {\n            // console.log(\"Validating existing position parameters\");\n            (\n                , , , , \n                uint24 existingFee,\n                int24 existingTickLower,\n                int24 existingTickUpper,\n                , , , , \n            ) = IPositionManager(positionManager).positions(params.tokenId);\n            \n            // console.log(\"Existing fee:\", existingFee);\n            // console.logInt(existingTickLower);\n            // console.logInt(existingTickUpper);\n            \n            require(existingFee == params.feeTier, \"Fee tier mismatch\");\n            require(existingTickLower == params.tickLower, \"Tick lower mismatch\");\n            require(existingTickUpper == params.tickUpper, \"Tick upper mismatch\");\n            // console.log(\"Existing position validation passed\");\n        }\n\n        // console.log(\"Starting token transfers and approvals\");\n\n        // 1) Pull in tokens and approve\n        IERC20(params.token0).safeTransferFrom(msg.sender, address(this), params.amount0Desired);\n        IERC20(params.token1).safeTransferFrom(msg.sender, address(this), params.amount1Desired);\n        IERC20(params.token0).approve(exchangeRouter, params.amount0Desired);\n        IERC20(params.token1).approve(exchangeRouter, params.amount1Desired);\n        IERC20(params.token0).approve(positionManager, type(uint256).max);\n        IERC20(params.token1).approve(positionManager, type(uint256).max);\n\n        console.log(\"Token transfers and approvals completed\");\n\n        \n        // Get current sqrt price from the pool\n        // console.log(\"Getting pool and sqrt price\");\n        address poolAddress = IUniswapV3Factory(liquidityPoolFactory).getPool(\n            params.token0, \n            params.token1, \n            params.feeTier\n        );\n        console.log(\"Pool address:\", poolAddress);\n        \n        (uint160 _sqrtP, , , , , , ) = IUniswapV3PoolState(poolAddress).slot0();\n        console.log(\"Current sqrt price:\", _sqrtP);\n\n        // Calculate the maximum liquidity that can be provided with the given token amounts\n        console.log(\"Calculating liquidity amounts\");\n        uint128 _maxLiquidity = _LiquidityAmounts.getLiquidityForAmounts(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            params.amount0Desired,\n            params.amount1Desired\n        );\n        console.log(\"Max liquidity:\", _maxLiquidity);\n\n        // Then get the optimal amounts for that liquidity\n        (uint256 _optimalAmount0, uint256 _optimalAmount1) = _LiquidityAmounts.getAmountsForLiquidity(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            _maxLiquidity\n        );\n        console.log(\"Optimal amount0:\", _optimalAmount0);\n        console.log(\"Optimal amount1:\", _optimalAmount1);\n\n        // 3) Execute swap if needed\n        uint256 _rangeRatio = _optimalAmount1 > 0 \n            ? (_optimalAmount0 * 1e18) / _optimalAmount1 \n            : 1e18;\n        uint256 _currentRatio = params.amount1Desired > 0 \n            ? (params.amount0Desired * 1e18) / params.amount1Desired \n            : type(uint256).max;\n        \n        console.log(\"Range ratio:\", _rangeRatio);\n        console.log(\"Current ratio:\", _currentRatio);\n        \n        if (_currentRatio > _rangeRatio) {\n            console.log(\"Executing swap: token0 -> token1\");\n            _executeSwap(\n                params.token0, \n                params.token1, \n                params.feeTier, \n                params.amount0Desired, \n                params.amount1Desired, \n                _rangeRatio\n            );\n        } else if (_currentRatio < _rangeRatio && _rangeRatio > 0) {\n            console.log(\"Executing swap: token1 -> token0\");\n            _executeSwap(\n                params.token1, \n                params.token0, \n                params.feeTier, \n                params.amount1Desired, \n                params.amount0Desired, \n                1e18 / _rangeRatio\n            );\n        } else {\n            // console.log(\"No swap needed\");\n        }\n\n        // 4) Mint position or increase liquidity and refund\n        _used0 = IERC20(params.token0).balanceOf(address(this));\n        _used1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Used amount0:\", _used0);\n        console.log(\"Used amount1:\", _used1);\n\n        if (params.tokenId == 0) {\n            // Mint new position\n            console.log(\"Minting new position\");\n            (_tokenId, , , ) = IPositionManager(positionManager).mint(\n                IPositionManager.MintParams({\n                    token0: params.token0,\n                    token1: params.token1,\n                    fee: params.feeTier,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: msg.sender,\n                    deadline: block.timestamp\n                })\n            );\n            console.log(\"New position minted - TokenId:\", _tokenId);\n        } else {\n            // Increase liquidity of existing position\n            // console.log(\"Increasing liquidity of existing position\");\n            _tokenId = params.tokenId;\n            IPositionManager(positionManager).increaseLiquidity(\n                IPositionManager.IncreaseLiquidityParams({\n                    tokenId: params.tokenId,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            // console.log(\"Liquidity increased - TokenId:\", _tokenId);\n        }\n\n        // Refund remaining tokens\n        uint256 _remaining0 = IERC20(params.token0).balanceOf(address(this));\n        uint256 _remaining1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Remaining amount0:\", _remaining0);\n        console.log(\"Remaining amount1:\", _remaining1);\n        \n        if (_remaining0 > 0) IERC20(params.token0).safeTransfer(msg.sender, _remaining0);\n        if (_remaining1 > 0) IERC20(params.token1).safeTransfer(msg.sender, _remaining1);\n        \n        console.log(\"=== swapAndAddLiquidity END ===\");\n    }\n\n    // Private functions\n\n    function _buildInputSwap(\n        uint _amountIn,\n        uint _amountOutMin,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactInputParams memory) {\n        return\n            ISwapRouter.ExactInputParams({\n                path: convertedPath(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            });\n    }\n\n    function _buildOutputSwap(\n        uint _amountInMaximum,\n        uint _amountOut,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactOutputParams memory) {\n        return\n            ISwapRouter.ExactOutputParams({\n                path: convertedPathReversed(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountOut: _amountOut,\n                amountInMaximum: _amountInMaximum\n            });\n    }\n\n    /// @notice Check if exchanging is possible or not\n    /// @dev Avoid reverting by exchange router\n    /// @return True if exchange conditions are satisfied\n    /// @return Needed amount of input token\n    function _checkExchangeConditions(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        uint256 _deadline,\n        bool _isFixedToken\n    ) private returns (bool, uint) {\n        // Check deadline has not passed\n        if (_deadline < block.timestamp) {\n            return (false, 0);\n        }\n\n        if (_isFixedToken == true) {\n            // Input amount is fixed\n            // Find maximum output amount\n            (bool success, uint outputResult) = getExactInput(_path, _inputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_outputAmount > outputResult) {\n                // Result is not enough\n                return (false, 0);\n            }\n            return (true, _inputAmount);\n        } else {\n            // Output amount is fixed\n            // Find minimum input amount\n            (bool success, uint inputResult) = getExactOutput(_path, _outputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_inputAmount < inputResult) {\n                // Input amount is not enough\n                return (false, 0);\n            }\n            return (true, inputResult);\n        }\n    }\n\n    /// @notice Execute swap to achieve optimal ratio\n    function _executeSwap(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _amountInAvailable,\n        uint256 _amountOutAvailable,\n        uint256 _targetRatio\n    ) private returns (uint256 _sentAmount, uint256 _receivedAmount) {\n        _sentAmount = _findOptimalSwapAmount(\n            _tokenIn, _tokenOut, _fee, _amountInAvailable, _amountOutAvailable, _targetRatio\n        );\n        console.log(\"Swap amount:\", _sentAmount);\n\n        console.log(\"new ratio:\", (_amountInAvailable - _sentAmount) * 1e18 / (_amountOutAvailable + _receivedAmount));\n        console.log(\"target ratio:\", _targetRatio);\n        \n        if (_sentAmount > 0) {\n            ISwapRouter.ExactInputSingleParams memory _params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _fee,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _sentAmount,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n            _receivedAmount = ISwapRouter(exchangeRouter).exactInputSingle(_params);\n        }\n    }\n\n    uint8  private constant MAX_ITERS = 20;\n\n    /// @notice Estimate how much of tokenIn to swap so that\n    ///         (in - x)/(out + y) â‰ˆ targetRatio, then refine with a capped binary search.\n    function _findOptimalSwapAmount(\n        address _tokenIn,\n        address _tokenOut,\n        uint24  _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) internal returns (uint256) {\n        if (amountIn == 0 || targetRatio == 0) return 0;\n\n        // Quick ratio check\n        if (amountOut > 0) {\n            uint256 currentRatio = (amountIn * 1e18) / amountOut;\n            if (currentRatio == targetRatio) return 0;\n        }\n\n        // Calculate initial guess\n        uint256 guess = _calculateInitialGuess(amountIn, amountOut, targetRatio);\n        console.log(\"Initial guess:\", guess);\n        \n        // Binary search with reduced variables\n        return _binarySearch(_tokenIn, _tokenOut, _fee, amountIn, amountOut, targetRatio, guess);\n    }\n\n    function _calculateInitialGuess(\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) private pure returns (uint256) {\n        if (amountOut == 0) return amountIn / 2;\n        \n        uint256 currentRatio = (amountIn * 1e18) / amountOut;\n        uint256 guess = currentRatio > targetRatio\n            ? ((currentRatio - targetRatio) * amountOut) / targetRatio\n            : ((targetRatio - currentRatio) * amountIn) / targetRatio;\n            \n        return guess > amountIn ? amountIn : guess;\n    }\n\n    function _getQuoteResult(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn\n    ) private returns (uint256 amountOut) {\n        (amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInputSingle(\n            IQuoterV2.QuoteExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: fee,\n                amountIn: amountIn,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function _binarySearch(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio,\n        uint256 guess\n    ) private returns (uint256) {\n        uint256 left = guess > amountIn/4 ? guess - amountIn/4 : 1;\n        uint256 right = guess + amountIn/4;\n        console.log(\"Left:\", left);\n        console.log(\"Right:\", right);\n        if (right > amountIn) right = amountIn;\n        console.log(\"Right after:\", right);\n\n        for (uint8 i = 0; i < MAX_ITERS && left <= right; ++i) {\n            uint256 mid = (left + right) >> 1;\n            console.log(\"Mid:\", mid);\n            \n            uint256 y = _getQuoteResult(_tokenIn, _tokenOut, _fee, mid);\n            console.log(\"Y:\", y);\n\n            if (amountOut + y == 0) {\n                right = mid - 1;\n                continue;\n            }\n            \n            uint256 newRatio = ((amountIn - mid) * 1e18) / (amountOut + y);\n            console.log(\"New ratio:\", newRatio);\n\n            if (newRatio > targetRatio) {\n                left = mid + 1;\n            } else if (newRatio < targetRatio) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n\n        return right;\n    }\n}\n","contract":"UniswapV3Connector","function":"_binarySearch","line":735,"range":[26264,26311]},"functionType":1},{"type":0,"sourceReference":{"sourceName":"contracts/dex_connectors/UniswapV3Connector.sol","sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./DexConnectorStorage.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol\";\nimport \"./uniswap_v4_helpers/_LiquidityAmounts.sol\";\nimport \"./uniswap_v4_helpers/_TickMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n\n// Simplified interface for Uniswap V3 Position Manager\ninterface IPositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function mint(MintParams calldata params) external payable returns (\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function positions(uint256 tokenId) external view returns (\n        uint96 nonce,\n        address operator,\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 tokensOwed0,\n        uint128 tokensOwed1\n    );\n}\n\ncontract UniswapV3Connector is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DexConnectorStorage\n{\n    modifier nonZeroAddress(address _address) {\n        require(_address != address(0), \"UniswapV3Connector: zero address\");\n        _;\n    }\n\n    using SafeERC20 for IERC20;\n\n    /// @notice This contract is used for interacting with UniswapV3 contract\n    /// @param _name Name of the underlying DEX\n    /// @param _exchangeRouter Address of the DEX router contract\n    function initialize(\n        string memory _name,\n        address _exchangeRouter,\n        address _quoterAddress\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        name = _name;\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n        quoterAddress = _quoterAddress;\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    function renounceOwnership() public virtual override onlyOwner {}\n\n    /// @notice Setter for wrapped native token\n    /// @dev Get address from exchange router\n    function setWrappedNativeToken() external override onlyOwner {\n        wrappedNativeToken = IPeripheryImmutableState(exchangeRouter).WETH9();\n    }\n\n    /// @notice Setter for exchange router\n    /// @dev Set address of liquidity pool factory from the exchange router\n    /// @param _exchangeRouter Address of the new exchange router contract\n    function setExchangeRouter(\n        address _exchangeRouter\n    ) external override nonZeroAddress(_exchangeRouter) onlyOwner {\n        exchangeRouter = _exchangeRouter;\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for liquidity pool factory\n    /// @dev Set address from exchange router\n    function setLiquidityPoolFactory() external override onlyOwner {\n        liquidityPoolFactory = IPeripheryImmutableState(exchangeRouter).factory();\n    }\n\n    /// @notice Setter for quoter\n    function setQuoter(address _quoterAddress) external onlyOwner {\n        quoterAddress = _quoterAddress;\n    }\n\n    /// @notice Setter for position manager\n    function setPositionManager(address _positionManager) external onlyOwner {\n        positionManager = _positionManager;\n    }\n\n    /// @notice Setter for fee tier\n    /// @dev We set the fee tier that is used for exchanging tokens\n    function setFeeTier(\n        address _firstToken,\n        address _secondToken,\n        uint24 _feeTier\n    ) external onlyOwner {\n        feeTier[_firstToken][_secondToken] = _feeTier;\n        feeTier[_secondToken][_firstToken] = _feeTier;\n    }\n\n    function convertedPath(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[0]);\n\n        for (uint i = 1; i < _path.length; i++) {\n            address firstToken = _path[i - 1];\n            address secondToken = _path[i];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    function convertedPathReversed(\n        address[] memory _path\n    ) public view returns (bytes memory packedData) {\n        packedData = abi.encodePacked(_path[_path.length - 1]);\n\n        for (uint i = _path.length - 1; i > 0; i--) {\n            address firstToken = _path[i];\n            address secondToken = _path[i - 1];\n            uint24 _feeTier = feeTier[firstToken][secondToken];\n            packedData = abi.encodePacked(packedData, _feeTier, secondToken);\n        }\n    }\n\n    /// @notice Return the needed input amount to get the output amount\n    /// @dev Return (false, 0) if DEX cannot give the output amount. \n    ///      Note: No need to reverse the path for this function\n    function getExactOutput(\n        address[] memory _path,\n        uint256 _amountOut\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountIn, , , ) = IQuoterV2(quoterAddress).quoteExactOutput(\n            convertedPathReversed(_path),\n            _amountOut\n        );\n        return (true, amountIn);\n    }\n\n    /// @notice Return the output amount for the given input amount\n    /// @dev Return (false, 0) if DEX cannot swap the input amount\n    function getExactInput(\n        address[] memory _path,\n        uint256 _amountIn\n    ) public returns (bool, uint256) {\n        if (!isPathValid(_path)) {\n            return (false, 0);\n        }\n        (uint amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInput(\n            convertedPath(_path),\n            _amountIn\n        );\n        return (true, amountOut);\n    }\n\n    /// @notice Deprecated for v3\n    function getInputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Deprecated for v3\n    function getOutputAmount(\n        uint,\n        address,\n        address\n    ) external pure override returns (bool, uint) {\n        return (true, 0);\n    }\n\n    /// @notice Return the square root price of given token pairs\n    function getSqrtPriceX96(\n        address[] memory _path\n    )\n        external\n        view\n        returns (uint[] memory _sqrtPriceX96, address[] memory _firstToken)\n    {\n        address liquidityPool;\n        uint sqrtPriceX96;\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            (sqrtPriceX96, , , , , , ) = IUniswapV3PoolState(liquidityPool).slot0();\n            _sqrtPriceX96[i] = sqrtPriceX96;\n            if (IUniswapV3PoolImmutables(liquidityPool).token0() == _path[i]) {\n                _firstToken[i] = _path[i];\n            } else {\n                _firstToken[i] = _path[i + 1];\n            }\n        }\n    }\n\n    /// @notice Exchange input token for output token through exchange router\n    /// @dev Check exchange conditions before exchanging\n    ///      We assume that the input token is not WETH (it is teleBTC)\n    /// @param _inputAmount Amount of input token\n    /// @param _outputAmount Amount of output token\n    /// @param _path List of tokens that are used for exchanging\n    /// @param _to Receiver address\n    /// @param _deadline Deadline of exchanging tokens\n    /// @param _isFixedToken True if the input token amount is fixed\n    /// @return _result True if the exchange is successful\n    /// @return _amounts Amounts of tokens that are involved in exchanging\n    function swap(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        address _to,\n        uint256 _deadline,\n        bool _isFixedToken\n    )\n        external\n        override\n        nonReentrant\n        nonZeroAddress(_to)\n        returns (bool _result, uint[] memory _amounts)\n    {\n        uint neededInputAmount;\n        (_result, neededInputAmount) = _checkExchangeConditions(\n            _inputAmount,\n            _outputAmount,\n            _path,\n            _deadline,\n            _isFixedToken\n        );\n\n        if (_result) {\n            uint _amount;\n            _amounts = new uint[](2);\n            // Get tokens from user\n            IERC20(_path[0]).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                neededInputAmount\n            );\n\n            // Give allowance to exchange router\n            IERC20(_path[0]).approve(exchangeRouter, neededInputAmount);\n\n            if (_isFixedToken == true) {\n                _amount = ISwapRouter(exchangeRouter).exactInput(\n                    _buildInputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = neededInputAmount;\n                _amounts[1] = _amount;\n            }\n\n            if (_isFixedToken == false) {\n                _amount = ISwapRouter(exchangeRouter).exactOutput(\n                    _buildOutputSwap(\n                        neededInputAmount,\n                        _outputAmount,\n                        _path,\n                        _to,\n                        _deadline\n                    )\n                );\n                _amounts[0] = _amount;\n                _amounts[1] = _outputAmount;\n            }\n            emit Swap(_path, _amounts, _to);\n        }\n    }\n\n    /// @notice Return true if the exchange path is valid\n    /// @param _path List of tokens that are used for exchanging\n    function isPathValid(\n        address[] memory _path\n    ) public view override returns (bool _result) {\n        address liquidityPool;\n\n        // Checks that path length is greater than one\n        if (_path.length < 2) {\n            return false;\n        }\n\n        for (uint i = 0; i < _path.length - 1; i++) {\n            liquidityPool = IUniswapV3Factory(liquidityPoolFactory).getPool(\n                _path[i],\n                _path[i + 1],\n                feeTier[_path[i]][_path[i + 1]]\n            );\n            if (liquidityPool == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    struct AddLiquidityParams {\n        uint256 tokenId; // 0 for new position, non-zero for existing position\n        address token0;\n        address token1;\n        uint24 feeTier;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n    }\n\n    /// @notice Zap tokens into a Uniswap V3 position in one call\n    function swapAndAddLiquidity(\n        AddLiquidityParams memory params\n    ) external nonReentrant returns (\n        uint256 _tokenId,\n        uint256 _used0,\n        uint256 _used1\n    ) {\n        // console.log(\"=== swapAndAddLiquidity START ===\");\n        // console.log(\"Position manager:\", positionManager);\n        // console.log(\"Token0:\", params.token0);\n        // console.log(\"Token1:\", params.token1);\n        // console.log(\"TokenId:\", params.tokenId);\n        // console.log(\"Amount0Desired:\", params.amount0Desired);\n        // console.log(\"Amount1Desired:\", params.amount1Desired);\n        // console.logInt(params.tickLower);\n        // console.logInt(params.tickUpper);\n        \n        // require(params.amount0Desired > 0 && params.amount1Desired > 0, \"Zero amounts\");\n\n        console.log(\"Basic validations passed\");\n\n        // If tokenId is non-zero, validate existing position parameters\n        if (params.tokenId != 0) {\n            // console.log(\"Validating existing position parameters\");\n            (\n                , , , , \n                uint24 existingFee,\n                int24 existingTickLower,\n                int24 existingTickUpper,\n                , , , , \n            ) = IPositionManager(positionManager).positions(params.tokenId);\n            \n            // console.log(\"Existing fee:\", existingFee);\n            // console.logInt(existingTickLower);\n            // console.logInt(existingTickUpper);\n            \n            require(existingFee == params.feeTier, \"Fee tier mismatch\");\n            require(existingTickLower == params.tickLower, \"Tick lower mismatch\");\n            require(existingTickUpper == params.tickUpper, \"Tick upper mismatch\");\n            // console.log(\"Existing position validation passed\");\n        }\n\n        // console.log(\"Starting token transfers and approvals\");\n\n        // 1) Pull in tokens and approve\n        IERC20(params.token0).safeTransferFrom(msg.sender, address(this), params.amount0Desired);\n        IERC20(params.token1).safeTransferFrom(msg.sender, address(this), params.amount1Desired);\n        IERC20(params.token0).approve(exchangeRouter, params.amount0Desired);\n        IERC20(params.token1).approve(exchangeRouter, params.amount1Desired);\n        IERC20(params.token0).approve(positionManager, type(uint256).max);\n        IERC20(params.token1).approve(positionManager, type(uint256).max);\n\n        console.log(\"Token transfers and approvals completed\");\n\n        \n        // Get current sqrt price from the pool\n        // console.log(\"Getting pool and sqrt price\");\n        address poolAddress = IUniswapV3Factory(liquidityPoolFactory).getPool(\n            params.token0, \n            params.token1, \n            params.feeTier\n        );\n        console.log(\"Pool address:\", poolAddress);\n        \n        (uint160 _sqrtP, , , , , , ) = IUniswapV3PoolState(poolAddress).slot0();\n        console.log(\"Current sqrt price:\", _sqrtP);\n\n        // Calculate the maximum liquidity that can be provided with the given token amounts\n        console.log(\"Calculating liquidity amounts\");\n        uint128 _maxLiquidity = _LiquidityAmounts.getLiquidityForAmounts(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            params.amount0Desired,\n            params.amount1Desired\n        );\n        console.log(\"Max liquidity:\", _maxLiquidity);\n\n        // Then get the optimal amounts for that liquidity\n        (uint256 _optimalAmount0, uint256 _optimalAmount1) = _LiquidityAmounts.getAmountsForLiquidity(\n            _sqrtP,\n            _TickMath.getSqrtPriceAtTick(params.tickLower),\n            _TickMath.getSqrtPriceAtTick(params.tickUpper),\n            _maxLiquidity\n        );\n        console.log(\"Optimal amount0:\", _optimalAmount0);\n        console.log(\"Optimal amount1:\", _optimalAmount1);\n\n        // 3) Execute swap if needed\n        uint256 _rangeRatio = _optimalAmount1 > 0 \n            ? (_optimalAmount0 * 1e18) / _optimalAmount1 \n            : 1e18;\n        uint256 _currentRatio = params.amount1Desired > 0 \n            ? (params.amount0Desired * 1e18) / params.amount1Desired \n            : type(uint256).max;\n        \n        console.log(\"Range ratio:\", _rangeRatio);\n        console.log(\"Current ratio:\", _currentRatio);\n        \n        if (_currentRatio > _rangeRatio) {\n            console.log(\"Executing swap: token0 -> token1\");\n            _executeSwap(\n                params.token0, \n                params.token1, \n                params.feeTier, \n                params.amount0Desired, \n                params.amount1Desired, \n                _rangeRatio\n            );\n        } else if (_currentRatio < _rangeRatio && _rangeRatio > 0) {\n            console.log(\"Executing swap: token1 -> token0\");\n            _executeSwap(\n                params.token1, \n                params.token0, \n                params.feeTier, \n                params.amount1Desired, \n                params.amount0Desired, \n                1e18 / _rangeRatio\n            );\n        } else {\n            // console.log(\"No swap needed\");\n        }\n\n        // 4) Mint position or increase liquidity and refund\n        _used0 = IERC20(params.token0).balanceOf(address(this));\n        _used1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Used amount0:\", _used0);\n        console.log(\"Used amount1:\", _used1);\n\n        if (params.tokenId == 0) {\n            // Mint new position\n            console.log(\"Minting new position\");\n            (_tokenId, , , ) = IPositionManager(positionManager).mint(\n                IPositionManager.MintParams({\n                    token0: params.token0,\n                    token1: params.token1,\n                    fee: params.feeTier,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: msg.sender,\n                    deadline: block.timestamp\n                })\n            );\n            console.log(\"New position minted - TokenId:\", _tokenId);\n        } else {\n            // Increase liquidity of existing position\n            // console.log(\"Increasing liquidity of existing position\");\n            _tokenId = params.tokenId;\n            IPositionManager(positionManager).increaseLiquidity(\n                IPositionManager.IncreaseLiquidityParams({\n                    tokenId: params.tokenId,\n                    amount0Desired: _used0,\n                    amount1Desired: _used1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            // console.log(\"Liquidity increased - TokenId:\", _tokenId);\n        }\n\n        // Refund remaining tokens\n        uint256 _remaining0 = IERC20(params.token0).balanceOf(address(this));\n        uint256 _remaining1 = IERC20(params.token1).balanceOf(address(this));\n        console.log(\"Remaining amount0:\", _remaining0);\n        console.log(\"Remaining amount1:\", _remaining1);\n        \n        if (_remaining0 > 0) IERC20(params.token0).safeTransfer(msg.sender, _remaining0);\n        if (_remaining1 > 0) IERC20(params.token1).safeTransfer(msg.sender, _remaining1);\n        \n        console.log(\"=== swapAndAddLiquidity END ===\");\n    }\n\n    // Private functions\n\n    function _buildInputSwap(\n        uint _amountIn,\n        uint _amountOutMin,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactInputParams memory) {\n        return\n            ISwapRouter.ExactInputParams({\n                path: convertedPath(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountIn: _amountIn,\n                amountOutMinimum: _amountOutMin\n            });\n    }\n\n    function _buildOutputSwap(\n        uint _amountInMaximum,\n        uint _amountOut,\n        address[] memory _path,\n        address _recipient,\n        uint _deadline\n    ) private view returns (ISwapRouter.ExactOutputParams memory) {\n        return\n            ISwapRouter.ExactOutputParams({\n                path: convertedPathReversed(_path),\n                recipient: _recipient,\n                deadline: _deadline,\n                amountOut: _amountOut,\n                amountInMaximum: _amountInMaximum\n            });\n    }\n\n    /// @notice Check if exchanging is possible or not\n    /// @dev Avoid reverting by exchange router\n    /// @return True if exchange conditions are satisfied\n    /// @return Needed amount of input token\n    function _checkExchangeConditions(\n        uint256 _inputAmount,\n        uint256 _outputAmount,\n        address[] memory _path,\n        uint256 _deadline,\n        bool _isFixedToken\n    ) private returns (bool, uint) {\n        // Check deadline has not passed\n        if (_deadline < block.timestamp) {\n            return (false, 0);\n        }\n\n        if (_isFixedToken == true) {\n            // Input amount is fixed\n            // Find maximum output amount\n            (bool success, uint outputResult) = getExactInput(_path, _inputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_outputAmount > outputResult) {\n                // Result is not enough\n                return (false, 0);\n            }\n            return (true, _inputAmount);\n        } else {\n            // Output amount is fixed\n            // Find minimum input amount\n            (bool success, uint inputResult) = getExactOutput(_path, _outputAmount);\n            if (success == false) {\n                return (false, 0);\n            }\n            if (_inputAmount < inputResult) {\n                // Input amount is not enough\n                return (false, 0);\n            }\n            return (true, inputResult);\n        }\n    }\n\n    /// @notice Execute swap to achieve optimal ratio\n    function _executeSwap(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _amountInAvailable,\n        uint256 _amountOutAvailable,\n        uint256 _targetRatio\n    ) private returns (uint256 _sentAmount, uint256 _receivedAmount) {\n        _sentAmount = _findOptimalSwapAmount(\n            _tokenIn, _tokenOut, _fee, _amountInAvailable, _amountOutAvailable, _targetRatio\n        );\n        console.log(\"Swap amount:\", _sentAmount);\n\n        console.log(\"new ratio:\", (_amountInAvailable - _sentAmount) * 1e18 / (_amountOutAvailable + _receivedAmount));\n        console.log(\"target ratio:\", _targetRatio);\n        \n        if (_sentAmount > 0) {\n            ISwapRouter.ExactInputSingleParams memory _params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _fee,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _sentAmount,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n            _receivedAmount = ISwapRouter(exchangeRouter).exactInputSingle(_params);\n        }\n    }\n\n    uint8  private constant MAX_ITERS = 20;\n\n    /// @notice Estimate how much of tokenIn to swap so that\n    ///         (in - x)/(out + y) â‰ˆ targetRatio, then refine with a capped binary search.\n    function _findOptimalSwapAmount(\n        address _tokenIn,\n        address _tokenOut,\n        uint24  _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) internal returns (uint256) {\n        if (amountIn == 0 || targetRatio == 0) return 0;\n\n        // Quick ratio check\n        if (amountOut > 0) {\n            uint256 currentRatio = (amountIn * 1e18) / amountOut;\n            if (currentRatio == targetRatio) return 0;\n        }\n\n        // Calculate initial guess\n        uint256 guess = _calculateInitialGuess(amountIn, amountOut, targetRatio);\n        console.log(\"Initial guess:\", guess);\n        \n        // Binary search with reduced variables\n        return _binarySearch(_tokenIn, _tokenOut, _fee, amountIn, amountOut, targetRatio, guess);\n    }\n\n    function _calculateInitialGuess(\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio\n    ) private pure returns (uint256) {\n        if (amountOut == 0) return amountIn / 2;\n        \n        uint256 currentRatio = (amountIn * 1e18) / amountOut;\n        uint256 guess = currentRatio > targetRatio\n            ? ((currentRatio - targetRatio) * amountOut) / targetRatio\n            : ((targetRatio - currentRatio) * amountIn) / targetRatio;\n            \n        return guess > amountIn ? amountIn : guess;\n    }\n\n    function _getQuoteResult(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn\n    ) private returns (uint256 amountOut) {\n        (amountOut, , , ) = IQuoterV2(quoterAddress).quoteExactInputSingle(\n            IQuoterV2.QuoteExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: fee,\n                amountIn: amountIn,\n                sqrtPriceLimitX96: 0\n            })\n        );\n    }\n\n    function _binarySearch(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 targetRatio,\n        uint256 guess\n    ) private returns (uint256) {\n        uint256 left = guess > amountIn/4 ? guess - amountIn/4 : 1;\n        uint256 right = guess + amountIn/4;\n        console.log(\"Left:\", left);\n        console.log(\"Right:\", right);\n        if (right > amountIn) right = amountIn;\n        console.log(\"Right after:\", right);\n\n        for (uint8 i = 0; i < MAX_ITERS && left <= right; ++i) {\n            uint256 mid = (left + right) >> 1;\n            console.log(\"Mid:\", mid);\n            \n            uint256 y = _getQuoteResult(_tokenIn, _tokenOut, _fee, mid);\n            console.log(\"Y:\", y);\n\n            if (amountOut + y == 0) {\n                right = mid - 1;\n                continue;\n            }\n            \n            uint256 newRatio = ((amountIn - mid) * 1e18) / (amountOut + y);\n            console.log(\"New ratio:\", newRatio);\n\n            if (newRatio > targetRatio) {\n                left = mid + 1;\n            } else if (newRatio < targetRatio) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n\n        return right;\n    }\n}\n","contract":"UniswapV3Connector","function":"_getQuoteResult","line":704,"range":[25256,25549]},"functionType":1},{"type":18,"address":{"0":95,"1":200,"2":211,"3":38,"4":144,"5":204,"6":145,"7":212,"8":195,"9":157,"10":157,"11":58,"12":188,"13":189,"14":22,"15":152,"16":159,"17":135,"18":87,"19":7},"returnData":{"0":8,"1":195,"2":121,"3":160,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":32,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":37,"68":77,"69":111,"70":99,"71":107,"72":32,"73":111,"74":110,"75":32,"76":116,"77":104,"78":101,"79":32,"80":109,"81":101,"82":116,"83":104,"84":111,"85":100,"86":32,"87":105,"88":115,"89":32,"90":110,"91":111,"92":116,"93":32,"94":105,"95":110,"96":105,"97":116,"98":105,"99":97,"100":108,"101":105,"102":122,"103":101,"104":100,"105":0,"106":0,"107":0,"108":0,"109":0,"110":0,"111":0,"112":0,"113":0,"114":0,"115":0,"116":0,"117":0,"118":0,"119":0,"120":0,"121":0,"122":0,"123":0,"124":0,"125":0,"126":0,"127":0,"128":0,"129":0,"130":0,"131":0},"isInvalidOpcodeError":false}],"data":"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000254d6f636b206f6e20746865206d6574686f64206973206e6f7420696e697469616c697a6564000000000000000000000000000000000000000000000000000000"}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)
      at Logger.makeError (node_modules/@ethersproject/logger/src.ts/index.ts:269:28)
      at Logger.throwError (node_modules/@ethersproject/logger/src.ts/index.ts:281:20)
      at checkError (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:78:20)
      at EthersProviderWrapper.<anonymous> (node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts:642:20)
      at step (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:48:23)
      at Object.throw (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:29:53)
      at rejected (node_modules/@ethersproject/providers/lib/json-rpc-provider.js:21:65)



